<!DOCTYPE html>
<html lang="it">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Snake 3D</title>
  <style>
    body {
      margin: 0;
      font-family: 'Arial', sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      overflow: hidden;
      touch-action: none;
    }

    #gameContainer {
      position: relative;
      width: 100vw;
      height: 100vh;
    }

    #ui {
      position: absolute;
      top: 20px;
      left: 20px;
      z-index: 100;
      font-size: 18px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
    }

    #score {
      margin-bottom: 10px;
      font-weight: bold;
    }

    #gameOver {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 100;
      text-align: center;
      background: rgba(0, 0, 0, 0.8);
      padding: 30px;
      border-radius: 15px;
      backdrop-filter: blur(10px);
      display: none;
    }

    #gameOver h1 {
      margin: 0 0 20px 0;
      font-size: 3em;
      background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    #gameOver p {
      font-size: 1.5em;
      margin: 10px 0;
    }

    #restartBtn {
      padding: 15px 30px;
      font-size: 18px;
      background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
      border: none;
      border-radius: 25px;
      color: white;
      cursor: pointer;
      transition: all 0.3s ease;
      margin-top: 20px;
    }

    #restartBtn:hover {
      transform: scale(1.1);
      box-shadow: 0 10px 20px rgba(0,0,0,0.3);
    }

    #controls {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: grid;
      grid-template-areas:
        ". up ."
        "left . right"
        ". down .";
      grid-template-columns: 60px 60px 60px;
      grid-template-rows: 60px 60px 60px;
      gap: 10px;
      z-index: 100;
    }

    #controls button {
      font-size: 24px;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.2);
      border: 2px solid rgba(255, 255, 255, 0.3);
      color: white;
      backdrop-filter: blur(10px);
      cursor: pointer;
      transition: all 0.2s ease;
    }

    #controls button:active {
      background: rgba(255, 255, 255, 0.4);
      transform: scale(0.95);
    }

    #up { grid-area: up; }
    #down { grid-area: down; }
    #left { grid-area: left; }
    #right { grid-area: right; }

    #instructions {
      position: absolute;
      top: 20px;
      right: 20px;
      z-index: 100;
      text-align: right;
      font-size: 14px;
      opacity: 0.8;
    }

    @media (max-width: 768px) {
      #controls {
        bottom: 50px;
      }
      
      #controls button {
        width: 50px;
        height: 50px;
        font-size: 20px;
      }
      
      #controls {
        grid-template-columns: 50px 50px 50px;
        grid-template-rows: 50px 50px 50px;
      }
    }
  </style>
</head>

<body>
  <div id="gameContainer">
    <div id="ui">
      <div id="score">Score: 0</div>
      <div id="speed">Speed: 1</div>
    </div>
    
    <div id="gameOver">
      <h1>Game Over!</h1>
      <p id="finalScore">Final Score: 0</p>
      <p id="highScore">Best Score: 0</p>
      <button id="restartBtn">Play Again</button>
    </div>

    
    <div id="controls">
      <button id="up">↑</button>
      <button id="left">←</button>
      <button id="down">↓</button>
      <button id="right">→</button>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // Game variables
    let scene, camera, renderer;
    let snake = [];
    let food;
    let direction = null;
    let nextDirection = null;
    let gameRunning = false;
    let gameSpeed = 150;
    let score = 0;
    let highScore = 0;
    
    // Game board
    const BOARD_SIZE = 20;
    const CUBE_SIZE = 0.8;
    const SPACING = 1;
    
    // Colors
    const COLORS = {
      background: 0x1a1a2e,
      snake: 0x00ff88,
      snakeHead: 0x00ff88, 
      ground: 0xFFFFFFF,
      gridLine: 0x0f172a
    };
    
    // Food colors and shapes
    const FOOD_COLORS = [
      0xff3366, 0xff6b35, 0xf7931e, 0xffd23f,
      0x06ffa5, 0x36bcf7, 0x8b5fbf, 0xff006e,
      0x00d2ff, 0xff9500, 0x7209b7, 0x560bad
    ];
    
    const FOOD_SHAPES = ['box', 'sphere', 'cylinder', 'octahedron', 'dodecahedron'];

    // Initialize the game
    function init() {
      createScene();
      createLighting();
      createGround();
      resetGame();
      animate();
      setupEventListeners();
      
      // Load high score
      highScore = parseInt(localStorage.getItem('snake3d_highscore')) || 0;
      updateHighScoreDisplay();
    }

    function createScene() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(COLORS.background);
      scene.fog = new THREE.Fog(COLORS.background, 10, 50);

      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 25, 12);
      camera.lookAt(0, 0, 0);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.getElementById('gameContainer').appendChild(renderer.domElement);
    }

    function createLighting() {
      // Ambient light
      const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
      scene.add(ambientLight);

      // Main directional light
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(10, 20, 5);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 2048;
      directionalLight.shadow.mapSize.height = 2048;
      directionalLight.shadow.camera.near = 0.5;
      directionalLight.shadow.camera.far = 50;
      directionalLight.shadow.camera.left = -15;
      directionalLight.shadow.camera.right = 15;
      directionalLight.shadow.camera.top = 15;
      directionalLight.shadow.camera.bottom = -15;
      scene.add(directionalLight);

      // Colored accent lights
      const redLight = new THREE.PointLight(0xff3366, 0.5, 20);
      redLight.position.set(-8, 5, -8);
      scene.add(redLight);

      const blueLight = new THREE.PointLight(0x3366ff, 0.5, 20);
      blueLight.position.set(8, 5, 8);
      scene.add(blueLight);
    }

    function createGround() {
      // Ground plane
      const groundGeometry = new THREE.PlaneGeometry(BOARD_SIZE, BOARD_SIZE);
      const groundMaterial = new THREE.MeshLambertMaterial({ 
        color: COLORS.ground,
        transparent: true,
        opacity: 0.8
      });
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);

      // Grid lines
      const gridGroup = new THREE.Group();
      const lineMaterial = new THREE.LineBasicMaterial({ 
        color: COLORS.gridLine,
        transparent: true,
        opacity: 0.3
      });

      for (let i = 0; i <= BOARD_SIZE; i++) {
        const points = [];
        points.push(new THREE.Vector3(-BOARD_SIZE/2, 0.01, -BOARD_SIZE/2 + i));
        points.push(new THREE.Vector3(BOARD_SIZE/2, 0.01, -BOARD_SIZE/2 + i));
        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const line = new THREE.Line(geometry, lineMaterial);
        gridGroup.add(line);

        const points2 = [];
        points2.push(new THREE.Vector3(-BOARD_SIZE/2 + i, 0.01, -BOARD_SIZE/2));
        points2.push(new THREE.Vector3(-BOARD_SIZE/2 + i, 0.01, BOARD_SIZE/2));
        const geometry2 = new THREE.BufferGeometry().setFromPoints(points2);
        const line2 = new THREE.Line(geometry2, lineMaterial);
        gridGroup.add(line2);
      }
      scene.add(gridGroup);
    }

    function createSnakeSegment(isHead = false) {
      const geometry = new THREE.BoxGeometry(CUBE_SIZE, CUBE_SIZE, CUBE_SIZE);
      const material = new THREE.MeshLambertMaterial({ 
        color: isHead ? COLORS.snakeHead : COLORS.snake,
        transparent: true,
        opacity: 0.9
      });
      const cube = new THREE.Mesh(geometry, material);
      cube.castShadow = true;
      cube.receiveShadow = true;
      
      // Add glow effect for head
      if (isHead) {
        const glowGeometry = new THREE.BoxGeometry(CUBE_SIZE * 1.2, CUBE_SIZE * 1.2, CUBE_SIZE * 1.2);
        const glowMaterial = new THREE.MeshBasicMaterial({
          color: COLORS.snakeHead,
          transparent: true,
          opacity: 0.3
        });
        const glow = new THREE.Mesh(glowGeometry, glowMaterial);
        cube.add(glow);
      }
      
      return cube;
    }

    function createFood() {
      const shape = FOOD_SHAPES[Math.floor(Math.random() * FOOD_SHAPES.length)];
      const color = FOOD_COLORS[Math.floor(Math.random() * FOOD_COLORS.length)];
      
      let geometry;
      switch (shape) {
        case 'sphere':
          geometry = new THREE.SphereGeometry(CUBE_SIZE/2, 8, 6);
          break;
        case 'cylinder':
          geometry = new THREE.CylinderGeometry(CUBE_SIZE/3, CUBE_SIZE/3, CUBE_SIZE, 8);
          break;
        case 'octahedron':
          geometry = new THREE.OctahedronGeometry(CUBE_SIZE/2);
          break;
        case 'dodecahedron':
          geometry = new THREE.DodecahedronGeometry(CUBE_SIZE/2.5);
          break;
        default: // box
          geometry = new THREE.BoxGeometry(CUBE_SIZE, CUBE_SIZE, CUBE_SIZE);
      }
      
      const material = new THREE.MeshLambertMaterial({ 
        color: color,
        emissive: color,
        emissiveIntensity: 0.2
      });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      
      // Add pulsing animation
      mesh.userData.originalScale = 1;
      mesh.userData.pulsePhase = Math.random() * Math.PI * 2;
      mesh.userData.rotationSpeed = {
        x: (Math.random() - 0.5) * 0.04,
        y: (Math.random() - 0.5) * 0.04,
        z: (Math.random() - 0.5) * 0.04
      };
      
      return mesh;
    }

    function gridToWorld(x, y) {
      return {
        x: (x - BOARD_SIZE/2 + 0.5) * SPACING,
        z: (y - BOARD_SIZE/2 + 0.5) * SPACING
      };
    }

    function spawnFood() {
      let foodPos;
      do {
        foodPos = {
          x: Math.floor(Math.random() * BOARD_SIZE),
          y: Math.floor(Math.random() * BOARD_SIZE)
        };
      } while (snake.some(segment => segment.x === foodPos.x && segment.y === foodPos.y));
      
      if (food) {
        scene.remove(food);
      }
      
      food = createFood();
      const worldPos = gridToWorld(foodPos.x, foodPos.y);
      food.position.set(worldPos.x, CUBE_SIZE/2, worldPos.z);
      food.userData.gridPos = foodPos;
      scene.add(food);
    }

    function resetGame() {
      // Clear existing snake
      snake.forEach(segment => {
        if (segment.mesh) {
          scene.remove(segment.mesh);
        }
      });
      
      // Initialize snake
      snake = [
        { x: Math.floor(BOARD_SIZE/2), y: Math.floor(BOARD_SIZE/2), mesh: null }
      ];
      
      // Create snake head
      snake[0].mesh = createSnakeSegment(true);
      const worldPos = gridToWorld(snake[0].x, snake[0].y);
      snake[0].mesh.position.set(worldPos.x, CUBE_SIZE/2, worldPos.z);
      scene.add(snake[0].mesh);
      
      direction = null;
      nextDirection = null;
      gameRunning = false;
      score = 0;
      gameSpeed = 150;
      updateScore();
      
      spawnFood();
      
      document.getElementById('gameOver').style.display = 'none';
    }

    function moveSnake() {
      if (!gameRunning || !direction) return;
      
      // Update direction
      if (nextDirection && isValidDirection(nextDirection)) {
        direction = nextDirection;
        nextDirection = null;
      }
      
      const head = snake[0];
      let newX = head.x;
      let newY = head.y;
      
      switch (direction) {
        case 'UP': newY--; break;
        case 'DOWN': newY++; break;
        case 'LEFT': newX--; break;
        case 'RIGHT': newX++; break;
      }
      
      // Check collisions
      if (newX < 0 || newX >= BOARD_SIZE || newY < 0 || newY >= BOARD_SIZE ||
          snake.some(segment => segment.x === newX && segment.y === newY)) {
        gameOver();
        return;
      }
      
      // Check food collision
      const ateFood = (newX === food.userData.gridPos.x && newY === food.userData.gridPos.y);
      
      // Move snake
      const newHead = { x: newX, y: newY, mesh: createSnakeSegment(true) };
      const worldPos = gridToWorld(newX, newY);
      newHead.mesh.position.set(worldPos.x, CUBE_SIZE/2, worldPos.z);
      scene.add(newHead.mesh);
      
      // Update old head to body segment
      if (snake[0].mesh) {
        scene.remove(snake[0].mesh);
        snake[0].mesh = createSnakeSegment(false);
        const oldWorldPos = gridToWorld(snake[0].x, snake[0].y);
        snake[0].mesh.position.set(oldWorldPos.x, CUBE_SIZE/2, oldWorldPos.z);
        scene.add(snake[0].mesh);
      }
      
      snake.unshift(newHead);
      
      if (ateFood) {
        score++;
        gameSpeed = Math.max(80, gameSpeed - 2);
        updateScore();
        spawnFood();
        
        // Update high score
        if (score > highScore) {
          highScore = score;
          localStorage.setItem('snake3d_highscore', highScore.toString());
          updateHighScoreDisplay();
        }
      } else {
        // Remove tail
        const tail = snake.pop();
        if (tail.mesh) {
          scene.remove(tail.mesh);
        }
      }
    }

    function isValidDirection(newDir) {
      if (!direction) return true;
      if (newDir === 'UP' && direction === 'DOWN') return false;
      if (newDir === 'DOWN' && direction === 'UP') return false;
      if (newDir === 'LEFT' && direction === 'RIGHT') return false;
      if (newDir === 'RIGHT' && direction === 'LEFT') return false;
      return true;
    }

    function setDirection(newDir) {
      if (!gameRunning && !direction) {
        gameRunning = true;
      }
      
      if (isValidDirection(newDir)) {
        if (!direction) {
          direction = newDir;
        } else {
          nextDirection = newDir;
        }
      }
    }

    function gameOver() {
      gameRunning = false;
      document.getElementById('finalScore').textContent = `Final Score: ${score}`;
      document.getElementById('gameOver').style.display = 'block';
    }

    function updateScore() {
      document.getElementById('score').textContent = `Score: ${score}`;
      document.getElementById('speed').textContent = `Speed: ${Math.floor((150 - gameSpeed) / 10) + 1}`;
    }

    function updateHighScoreDisplay() {
      document.getElementById('highScore').textContent = `Best Score: ${highScore}`;
    }

    function setupEventListeners() {
      // Keyboard controls
      document.addEventListener('keydown', (e) => {
        switch (e.key) {
          case 'ArrowUp': setDirection('UP'); e.preventDefault(); break;
          case 'ArrowDown': setDirection('DOWN'); e.preventDefault(); break;
          case 'ArrowLeft': setDirection('LEFT'); e.preventDefault(); break;
          case 'ArrowRight': setDirection('RIGHT'); e.preventDefault(); break;
          case 'Enter': if (!gameRunning && direction) resetGame(); break;
        }
      });

      // Touch controls
      document.getElementById('up').addEventListener('click', () => setDirection('UP'));
      document.getElementById('down').addEventListener('click', () => setDirection('DOWN'));
      document.getElementById('left').addEventListener('click', () => setDirection('LEFT'));
      document.getElementById('right').addEventListener('click', () => setDirection('RIGHT'));
      
      // Restart button
      document.getElementById('restartBtn').addEventListener('click', resetGame);
      
      // Window resize
      window.addEventListener('resize', onWindowResize);
      
      // Touch swipe controls
      let touchStartX = 0, touchStartY = 0;
      
      renderer.domElement.addEventListener('touchstart', (e) => {
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
        e.preventDefault();
      }, { passive: false });
      
      renderer.domElement.addEventListener('touchend', (e) => {
        const dx = e.changedTouches[0].clientX - touchStartX;
        const dy = e.changedTouches[0].clientY - touchStartY;
        const threshold = 50;
        
        if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > threshold) {
          setDirection(dx > 0 ? 'RIGHT' : 'LEFT');
        } else if (Math.abs(dy) > threshold) {
          setDirection(dy > 0 ? 'DOWN' : 'UP');
        }
        e.preventDefault();
      }, { passive: false });
      
      // Prevent scrolling
      document.body.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);
      
      // Animate food pulsing and rotation
      if (food) {
        food.userData.pulsePhase += 0.1;
        const scale = 1 + Math.sin(food.userData.pulsePhase) * 0.1;
        food.scale.setScalar(scale);
        
        // Random rotation for each axis
        food.rotation.x += food.userData.rotationSpeed.x;
        food.rotation.y += food.userData.rotationSpeed.y;
        food.rotation.z += food.userData.rotationSpeed.z;
      }
      
      // Camera slight movement
      camera.position.x = Math.sin(Date.now() * 0.0005) * 0.5;
      
      renderer.render(scene, camera);
    }

    // Game loop
    let lastTime = 0;
    function gameLoop(currentTime) {
      if (currentTime - lastTime > gameSpeed) {
        moveSnake();
        lastTime = currentTime;
      }
      requestAnimationFrame(gameLoop);
    }

    // Start the game
    init();
    gameLoop(0);
  </script>
</body>

</html>
